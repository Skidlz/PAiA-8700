;********************************
;*                              *
;*     ORGASMATRONIC GLIDE      *
;*                              *
;*  ARPEGIATION PROGRAMMER AND  *
;*           EDITOR             *
;*             BY               *
;*     JOHN S. SIMONTON, JR     *
;*                              *
;*(C) 1979 PAIA ELECTRONICS, INC*
;*                              *
;********************************
;
DECD	= $1F00	;PIEBUG DECODE
DISP	= $1820	;LED DISPLAY
INIT	= $1D21 ;MUS-1 INIT
NOTE	= $1D2B	;MUS-1 NOTEOUT
KTBL	= $00E0 ;MUS-1 INPUT BUFFER
NTBL	= $00D0	;MUS-1 OUTPUT BUFFER 
TTBL	= $00C0	;MUS-1 TRANSPOSE BUFFER
;
	org	$1000
;
;****** MONITOR SUBROUTINES ******
;THIS IS THE MAIN PROGRAM LOOP. START BY INITIALIZING THE SYNTHESIZER
;AND CALLING THE QUASH DRIVERS AND AGO KBD READING ROUTINES FROM MUS1
;CHECK TO SEE IF A COMMAND KEY HAS BEEN TOUCHED; AND IF SO, JUMP TO
;SUBROUTINE TO DETERMINE THE COMMAND AND EXECUTE IT. DETERMINE THE
;POINTER FOR THE OUTPUT CHANNEL AND JUMP TO SUBROUTINE FOR ORG. GLIDE
;PROCESSING.  ON RETURN, LOOP.
;
		jsr	INIT		;MUS1 SYNTH INIT ROUTINE
LOOP	jsr	NOTE		;QUASH DRIVERS AND READ AGO
		jsr	DECD		;PIEBUG READ COMMAND KBD
		bcs	HERE		;IF NO NEW KEY TOUCHED, SKIP NEXT
		jsr	CMND		;CALL COMMAND DECODER
HERE	ldy	#$0F		;POINTER TO ORG. GLIDE OUTPUT CHANNEL
		jsr	STAR		;CALL ORG. GLIDE PROGRAM
		jmp	LOOP		;LOOP TO CONTINUE
;
;FIRST THE TIMER IS TESTED AND IF NOT TIME FOR THE NEXT NOTE TO BE
;PROCESSED THE STACCATO CONTROL BIT IS CHECKED AND IF CLEAR
;(STACCATO) BRANCH IS TAKEN TO DE-TRIGGER NOTE IN OUTPUT
;BUFFER. IF LEGATO MODE, EXIT IS IMMEDIATE
;
STAR	bit	KTBL+7		;ARE THERE ANY AGO KEYS DOWN?
		bvc	SINT		;NO KEYS, BRANCH TO RE-INIT ARP. POINTER
		dec	<TIMR		;OTHERWISE, DECREMENT THE TIMER
		bmi	ADVA		;IF EVENT TIME, BRANCH
		bit	<SCTL		;OTHERWISE CHECK FOR STACCATO AND IF TRUE...
		bvc	CLRN		;BRANCH TO CLEAR TRIGGER FROM OUTPUT NOTE
		rts				;OTHERWISE, RETURN WITHOUT CLEARING TRIGGER
;
;IF IT'S TIME FOR A NOTE TO BE PROCESSED, THE POINTER TO THE INPUT
;BUFFER IS ADVANCED (EITHER FORWARD OR BACKWARD) AND IF THERE IS NO
;MORE BUFFER LEFT WE DROP THROUGH TO ADVANCE THE POINTER TO THE SEQUENCE
;BUFFER TO GET THE NEXT SET OF GLIDE PARAMETERS.  IF WE ARE NOT YET
;TO THE END OF THE IN BUFFER, WE BRANCH OUT TO RESET THE TIMER, ETC.
;
ADVA	ldx	<PNTR		;GET POINTER TO INPUT BUFFER
		bit	<SCTL		;CURRENTLY flRPEGGIATING UP?
		bpl	DOWN		;NO, BRANCH TO DO DOWN
		dex				;TO GO UP-SCALE, DECREMENT POINTER
		bmi	SADV		;IF POINTER NOW <0, BRANCH
		bpl	STIM		;STILL IN RANGE. BRANCH ALWAYS
DOWN	inx				;DOWN-SCALE. INCREMENT POINTER
		cpx	#$08		;OUT OF RANGE?
		bne	STIM		;STILL IN RANGE. BRANCH
;
;IF WE GET HERE (SADV) IT MEANS THAT WE HAVE PLAYED ALL OF THE KEYS
;THAT WERE DOWN AND HAVE REACHED THE END OF THE INPUT BUFFER
;NOW IT'S TIME TO GET THE NEXT ENTRY FROM THE CONTROL SEQUENCE.
;WE TEST TO SEE IF WE ARE AT THE END OF THE SEQUENCE AND IF SO THE
;POINTER IS RE-INITIALIZED. OTHERWISE, THE COMMAND IS FETCHED AND IF
;ZERO IT MERNS THAT IT IS THE END OF THE SEQUENCE AND THE POINTER
;IS ALSO REINITIALIZED
;
SADV	ldx	<SPNT		;GET CONTROL SEQUENCE POINTER
		dex				;POINT TO NEXT SEQUENCE ENTRY
		bpl	GSEQ		;IF NOT TO END. BRANCH
SINT	ldx	#$07		;RE-INIT SEQUENCE POINTER
GSEQ	stx	<SPNT		;SAVE SEQUENCE POINTER
		lda	<CSEQ,x		;GET COMMAND FROM CONTROL SEO.
		beq	SINT		;ZERO ENDS THE SEQUENCE. BRANCH
;
;A NEW COMMAND FROM THE SEQUENCE. FIRST USE IT TO SET OR CLEAR THE
;THE GLIDE CONTROL BIT FROM THE TRANSPOSE BUFFER. IN THE PROCESS,
;THE NEW COMMAND IS SHIFTED ONE BIT TO THE LEFT; WHICH MULTIPLIES
;THE TEMPO VARIABLE BY 2 AND SHIFTS THE UP/DOWN AND LEGA/STACC BITS
;INTO MORE EASILY TESTED POSITIONS.
;
GLID	sta	<SCTL		;SAVE SEQUENCE ENTRY IN CONTROL BUFFER
		lda	<TTBL,y		;GET THE CURRENT TRANSOSE BUFFER ENTRY
		rol	a			;ROTATE GLIDE BIT TO CARRY
		asl	<SCTL		;ROTATE CONTROL WORD GLIDE TO CARRY
		ror	a			;ROTATE CARRY TO GLIDE BIT
		sta	<TTBL,y		;THEN RETURN TO TRANSPOSE BUFFER
;
;THIS LITTLE ROUTINE DETERMINES WHETHER SCAN IS UP OR DOWN AND
;INITIALIZES THE POINTER TO THE PROPER VALUE
;SKVP-SET KEY POINTER
;
SKYP	ldx	#$07		;PREPARE FOR ARP. UP INITIAL POINTER
		bit	<SCTL		;CHECK COMMAND BUFFER - ARP. UP?
		bmi	STIM		;YES. BRANCH
		ldx	#$00		;NO, ARP. DOWN INTIAL POINTER
;
;NOW THE ROUTINE TO RESET THE TIMER. SINCE ALL KEY POINTER MANIPULATIONS
;WIND UP AT THIS POINT. THE FIRST INSTRUCTION IS TO SAVE THIS POINTER
;THE TIMER VALUE IS EXTRACTED FROM THE CONTROL WORD SCTL
;STIM-SET TIMER
;
STIM	stx	<PNTR		;SAVE INPUT BUFFER POINTER
		lda	#$1F		;PREPARE MASK AND
		and	<SCTL		;GET THE TIMER (TEMPO) VALUE
		sta	<TIMR		;AND SAVE IN THE TIMER VARIABLE
;
;NOW WE GET THE CURRENT NOTE OF INTEREST FROM THE INPUT BUFFER
;AND IF THE KEY IS NOT DOWN, A CHECK IS MADE TO SEE IF ANY KEYS
;ARE DOWN. IF NONE ARE, THE TIMER IS TRICKED INTO TIMING OUT THE
;NEXT TIME THROUGH WHICH WILL THEN RESULT IN THE WHOLE COMMAND
;SEQUENCE FOLLOWING SYSTEM BEING RESET
;
		lda	<KTBL,x		;GET THE CURRENT KEY FROM INPUT BUFFER
		bne	BOUT		;IF ZERO, NO KEY - BRANCH
		bit	<KTBL+7		;ARE ANY KEYS DOWN?
		bvs	ADVA		;YES, BRANCH
		lda	#$01		;NO, PREPARE TO MAKE TIMER RUN OUT
		sta	<TIMR		;NEXT PASS THROUGH
CLRN	lda	<NTBL,y		;GET THE CURRENT OUTPUT NOTE
		and	#$BF		;CLEAR THE TRIGGER FLAG
BOUT	sta	<NTBL,y		;AND REPLACE IN OUTPUT BUFFER
		rts				;RETURN
;NOW SOME TEMPORARY LOCATIONS AND THEIR INITIAL STATES
;
TEMP	db	$00
TIMR	db	$01
PNTR	db	$08
SCTL	db	$C4
PPNT	db	$07
SPNT	db	$07
CSEQ	db	$00, $00, $00, $00, $00, $00, $E4, $04
	org $10E8
STUP
CTRL	db	$40			;MUS1
ODLY	db	$20			;MUS1
OUTS	db	$01			;MUS1
	org $1100
;THIS IS THE COMMAND KEY DECODING AND SEQUENCE EDITING SUBROUTINE
;# OF COMMAND KEY IS IN Y REGISTER
;
CMND	ldx	<lo PPNT	;GET THE EDITORS POINTER TO COMMAND SEQ
		lda	<lo CSEQ,x	;GET THE COMMAND POINTED TO (IN ACC, DON'T FORGET)
		cpy	#$10		;IS KEY 10 - CLEAR COMMAND SEQUENCE
		beq	CLR			;YES, BRANCH
		bcc	CNXT		;NO, IT'S LESS THAN "F", BRANCH
;
;THE KEY IS 11 OR GREfiTER.  EXCHANGE THE COMMRND POINTED TO WITH
;TEMPORARY STORAGE LOCATION TEMP. NOTE THAT THIS CAN BE USED TO
;EXCHANGE TWO OR MORE COMMANDS IN THE SEQUENCE
;
		ldy	<lo TEMP	;GET THE COMMAND IN THE TEMPORARY BUFFER
		bne	ELP0		;IS THE COMMAND FROM TEMP A 0? NO, BRANCH
		cpx	#$07		;POINTING TO FIRST COMMAND?
		beq	RTN			;YES, BRANCH. DON'T WRITE ZERO AS FIRST COMMAtÂ©
ELP0	sty	<lo CSEQ,x	;PUT COMMRND IN THE SEQUENCE SLOT POINTED TO
		sta	<lo TEMP	;AND THEN SAVE OLD COMMAND IN THE TEMP LOCATION
		rts				;THEN RETURN
;
;THE KEY IS "10", CLEAR THE COMMAND SEQUENCE. NOTE THAT THE FIRST
;ENTRY IN THE SEQUENCE IS NOT CHANGED.
;
CLR		ldx	#$07		;SET POINT TO FIRST SEQUENCE ENTRY
		stx	<lo PPNT	;AND SAVE IT
		dex				;DECREMENT THE POINTER(SKIP FIRST ENTRY)
		lda	#$00		;AND GET READY
		sta	DISP		;ZERO THE DISPLAYED EDITOR POINTER
		sta	<lo TEMP	;AND THE EXCHANGE REGISTER
CLLP	sta	<lo CSEQ,x	;ZERO THE SEQUENCE ENTRY
		dex				;AND POINT TO NEXT ENTRY
		bpl	CLLP		;SOME LEFT, LOOP
		rts				;RETURN
;
;NOW WE TEST FOR "E" OR "F", BACKSPACE OR ADVANCE THE EDITOR'S
;EDITOR'S POINTER TO THE COMMAND SEQUENCE. NOTE THAT INCREMENTING THE
;POINTER PRODUCES A BACKSPACE.
;
CNXT	cpy	#$0E		;IS KEY "E" OR "F"?
		bcc	STMP		;NEITHER AND LESS THAN "E", BRANCH FOR NEXT TEST
		beq	BACK		;IT'S "E", BRANCH TO BACKSPACE
		dex				;IT'S "F", ADVANCE THE POINTER
		bmi	RTN			;AND IF OUT OF RANGE, BRANCH TO LEAVE IMMEDIATELY
COUT	stx	<lo PPNT	;SAVE NEW POINTER
;
;IN THIS SECTION THE POINTER (WiCH IS 07 FOR THE START OF THE SEQUENCE
;AND 00 AT THE END) IS CONVERTED TO AN INCREASING NUMBER FROM 0-7 FOR
;DISPLAY PURPOSES.
;
		txa				;POINTER TO THE ACCUM. FOR A CALCULATION
		sec				;PREPARE FOR A SUBTRACTION
		sbc	#$08		;TWO'SD COMPLEMENT
		eor	#$FF		;COMPLEMENT OF THAT
		sta	DISP		;SHOW VALUE IN THE DISPLAYS
RTN	rts					;RETURN
;
;BACKSPRCE POINTER AND MAKE SURE IT IS STILL IN RANGE, THEN BRANCH
;
BACK	inx				;BACKSPACE THE POINTER
		cpx	#$08		;OUT OF RANGE?
		beq	RTN			;YES, BRANCH TO LEAVE IMMEDIATELY
		bne	COUT		;NO, BRANCH ALWAYS TO SAVE POINTER, ETC.
;
;IF THE KEY IS ONE OF THE TEMPOS, ADD 1 (0 TEMPO NOT ALLOWED) AND
;FIT IT INTO THE CONTROL SEQUENCE ENTRY POINTED TO
;
STMP	cpy	#$08		;TEMPO KEY?
		bcs	SGLD		;NO, BRANCH
		iny				;YES, ADD 1 TO KEY #
		and	#$F0		;MASK PRESENT TEMPO IN COMMAND TO ERO
		sta	<lo CSEQ,x	;SAVE CONTROL FLAGS IN CSEQ TEMPORARILY
		tya				;BRING NEW TEMPO TO ACC
		ora	<lo CSEQ,x	;COMBINE WITH OLD CONTROL FLAGS
		bne	SAVA		;BRANCH ALWAYS
;
;NOW A SERIES OF TESTS WHICH RESULT IN THE CARRY BIT BEING SET OR
;CLEAR. A SERIES OF ROTATES BRINGS THE CARRY TO THE APPROPRIATE BIT
;IN THE COMMAND WORD
;
SGLD	rol	a			;ROTATE THE GLIDE COMMAND BIT TO CARRY
		php				;AND SAVE THE CARRY ON THE STACK
		cpy	#$09		;IS KEY GLIDE ON OR OFF?
		beq	ROT1		;9-GLIDE ON, BRANCH
		bcc	ROT1		;8-GLIDE OFF, BRANCH
;
;THE KEY HAS NEITHER GLIDE ON NOR OFF, TEST FOR DIRECTION UP OR DOOWN
;
SMOD	plp				;GET THE OLD GLIDE BIT FROM THE STACK
		rol	a			;ROTATE DIRECTION BIT TO CARRY
		php				;SAVE IT ON STACK
		cpy	#$0B		;IS KEV UP OR DOWN?
		beq	ROT2		;B-UP, BRANCH
		bcc	ROT2		;A-DOWN, BRANCH
;
;THE KEV HAS TO BE C OR D (STACCATO OR LEGATO)
;
SDIR	plp				;GET THE OLD DIRECTION BIT
		rol	a			;STAC/LEGA BIT TO CARRY
		php				;SAVE IT
		cpy	#$0D		;CARRY SETS IF KEY IS "D" - LEGATO
		ror	a			;ROTATE COMMAND HORD BACK INTO PLACE
ROT2	ror	a
ROT1	ror	a
		plp				;WASTE A STACK SLOT TO COMPENSATE
SAVA	sta	<lo CSEQ,x	;SAVE THE COMMAND HORD IN THE SEQUENCE
		rts				;RETURN
;
	end
