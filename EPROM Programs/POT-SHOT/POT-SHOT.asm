;
;
;
;  ********************************
;  *  POT-SHOT CASSETTE SYSTEM    *
;  *  WRITTEN BY ROGER WALKTON    *
;  *  COPYRIGHT 1977 BY PAIA      *
;  *    ELECTRONICS, INC.         *
;  *  VERSION 1.0                 *
;  ********************************
;
PORT	=$0900			;CASSETTE I/O PORT
DISPLY	=$0820			;LED DISPLAY
PIEBUG	=$0F52			;DISP ACC; GOTO PIEBUG
BEEP	=$0F22			;BEEP SUB IN PIEBUG
;
STATUS	=$EF			;INPUT BIT STATUS
CHKSUM	=$EE			;CHECKSUM
PNTER	=$F6			;16 BIT ADDR POINTER
COMAND	=$F0			;LOAD/DUMP COMMAND
IDENT	=$F1			;FILE IDENTIFIER
ENDADR	=$F2			;END ADDR
BEGADR	=$F4			;BEGINNING ADDR
;
	org	$0E00
;
START:	jsr	SNDBIT		;START TAPE
		sty	DISPLY		;CLEAR DISPLAY
		lda	BEGADR		;MOVE BEGINNING
		sta	PNTER		;  ADDR TO POINTER
		lda	BEGADR+1
		sta	PNTER+1
		lda	COMAND		;GET COMMAND
		beq	MANUAL		;BR IF COMMAND= "00"
		jsr	CASS		;DUMP OR LOAD BLOCK
		clc
		jsr	BEEP		;STOP TAPE AND BEEP
MANUAL: jmp	PIEBUG		;RETURN TO MONITOR
;
;
;
;		DELAY SUBROUTINE
;		THIS SUB DELAYS FOR ONE HALF CYCLE
;		(2000 HZ).  Y IS CLEARED, X, A, AND
;		CARRY ARE PRESERVED.
;
DELAY:	sta	PORT		;UPDATE TONE
		ldy	#$0F
DLY:	dey
		bne	DLY			;BR UNTIL DELAY FINISHED
		rts				;RETURN
;
;
;
;		SEND BIT SUBROUTINE
;		THIS SUB SENDS THE CARRY BIT TO THE TAPE.
;		AND "1" BIT CONSISTS OF 16 CYCLES OF 2000 HZ
;		AND A "0" BIT CONSISTS OF 8.  THIS SUB
;		TURNS RELAYS 1 ON AND RELAY 2 OFF.  Y IS
;		CLEARED, X, A, AND CARRY ARE PRESERVED.
;
SNDBIT:	pha				;SAVE A
		txa
		pha				;SAVE X
		ldx	#$10		;NO. OF CYCLES FOR A "1"
		bcs	CYCLE		;BRANCH IF "1" BIT
		ldx	#$08		;NO. OF CYCLES FOR A "0"
CYCLE:	lda	#%10110000	;TAPE ON; OUTPUT HIGH
		jsr	DELAY		;UPDATE PORT AND DELAY
		lda	#%10000000	;TAPE ON; OUTPUT LOW	
		jsr	DELAY		;UPDATE PORT AND DELAY
		dex				;LAST CYCLE?
		bne	CYCLE		;BRANCH IF NOT
		lda	#%10010000	;TAPE ON; OUTPUT NEUTRAL	
		ldx	#$10		;DELAY COUNTER
GAP:	jsr	DELAY		;PRODUCE A GAP
		dex				;DELAY FINISHED?
		bne	GAP			;BRANCH IF NOT
		pla
		tax				;RESTORE X
		pla				;RESTORE A
		rts				;RETURN
;
;
;
;		DETECT BIT SUBROUTINE
;		THIS SUB WILL PICK UP ONE BIT FROM
;		THE TAPE AND RETURN WITH IT IN THE
;		CARRY FLAG.  Y IS CLOBBERED, X AND A
;		ARE PRESERVED.  RELAYS ARE NOT AFFECTED.
;
DETBIT:	pha				;SAVE A
		txa
		pha				;SAVE X
TONE:	lda PORT		;LOOK FOR START OF TONE
		bpl	TONE		;BRANCH UNTIL FOUND
		ldx	#$00		;CLEAR COUNTER
COUNT:	inx				;COUNT TRANSISTIONS
		ldy	#$23		;TIME LIMIT
		lda	PORT		;CHECK INPUT
		sta	STATUS		;SAVE INPUT STATUS
CHECK:	lda PORT		;CHECK INPUT
		eor	STATUS		;HAS IT SWITCHED?
		bmi	COUNT		;IF SO, BRANCH
		dey				;TIME UP?
		bne	CHECK		;IF NOT, BRANCH
		cpx	#$08		;DOES TONE BURST QUALIFY?
		bcc	TONE		;BRANCH IF NOT
		cpx	#$18		;SEC IF "1"; CLC IF "0"
		pla
		tax				;RESTORE X
		pla				;RESTORE A
		rts				;RETURN
;
;
;
;		SEND BYTE SUBROUTINE
;		THIS SUB SENDS THE BYTE CONTAINED
;		IN THE ACC TO THE TAPE ALONG WITH
;		A START BIT AND ONE STOP BIT.  X AND
;		Y ARE CLEARED, A IS PRESERVED.
;		CARRY IS SET.  RELAY 1 IS TURNED ON,
;		RELAY 2 IS TURNED OFF.
;
SNDBYT:	clc
		jsr	SNDBIT		;SEND START BIT
		ldx	#$09		;SET BIT COUNTER TO 9
		sec				;SET STOP BIT
NEXT1:	rol	a			;MOVE BIT TO CARRY
		jsr	SNDBIT		;SEND IT
		dex				;LAST BIT?
		bne	NEXT1		;BRANCH IF NOT
		rts				;RETURN
;
;
;
;		GET BYTE SUBROUTINE
;		THIS SUB WILL PICK UP A  BYTE FROM
;		TAPE AND RETURN IT IN THE ACC.
;		X AND Y ARE CLEARED, CARRY CONTAINS
;		THE STOP BIT.  RELAYS ARE NOT AFFECTED.
;
GETBYT:	jsr	DETBIT		;LOOK FOR START BIT
		bcs	GETBYT		;BRANCH UNTIL FOUND
		ldx	#$09		;SET BIT COUNTER TO 9
NEXT2:	rol	a			;MOVE BIT TO ACC
		jsr	DETBIT		;GET NEXT BIT
		dex				;LAST BIT?
		bne	NEXT2		;BRANCH IF NOT
		rts				;RETURN
;
;
;
;		CHECK ADDRESS SUBROUTINE
;		THIS SUB COMPARES THE POINTER TO
;		THE END ADDRESS AND SETS THE CARRY
;		IF THEY ARE THE SAME.  IF THEY ARE
;		NOT, THE CARRY IS CLEARED AND POINTER
;		IS INCREMENTED.  IT ALSO ADDS THE
;		CONTENTS OF THE ACC TO THE CHECKSUM
;		AND DISPLAYS THE LOW BYTE OF POINTER.
;		A IS MUTILATED, X AND Y ARE PRESERVED
;		RELAYS ARE NOT AFFECTED.
;
CHKADD:	cld
		clc
		adc	CHKSUM		;UPDATE CHECKSUM
		sta	CHKSUM		;SAVE IT
		lda	PNTER		;GET POINTER LOW
		sta	DISPLY		;DISPLAY IT
		cmp	ENDADR		;CMP WITH END ADDR LOW
		bne	INCPTR		;BRANCH IF NOT EQUAL
		lda	PNTER+1		;GET POINTER HIGH
		cmp	ENDADR+1	;CMP WITH END ADDR HIGH
		beq	RET			;BRANCH AND SEC IF SAME
INCPTR:	inc	PNTER		;INC LOW BYTE
		bne	SKIP2		;BRANCH IF NO CARRY
		inc	PNTER+1		;INC HIGH BYTE
SKIP2:	clc
RET:	rts				;RETURN
;
;
;
;
CASS:	bpl	LOAD		;BR IF COMMAND= "LOAD"
;
;
;
;		DUMP BLOCK SUBROUTINE
;		THIS SUB TRANSFERS A BLOCK OF MEMORY
;		TO TAPE.  BEGINNING OF THE BLOCK IS
;		SPECIFIED WITH "PNTER", END OF THE
;		BLOCK WITH "ENDADR", AND BLOCK
;		INDENTIFICATION WITH "IDENT".  AA
;		CHECKSUM IS SENT AT THE END OF
;		THE BLOCK.  A, X, AND Y ARE CLEARED,
;		CARRY IS SET.  RELAY 1 IS TURNED ON,
;		RELAY 2 IS TURNED OFF.
;

DUMP:	ldx	#255		;SET UP BIT COUNTER
NEXT3:	sec				;"1" BIT
		jsr	SNDBIT		;SEND LEADER
		dex				;FINISHED?
		bne	NEXT3		;BRANCH IF NOT
;
		stx	CHKSUM		;CLEAR CHECKSUM
		lda	IDENT		;GET IDENTIFIER
		jsr	SNDBYT		;SEND IT
;
NEXT4:	lda	(PNTER,x)	;GET BYTE
		jsr	SNDBYT		;SEND IT
		jsr	CHKADD		;LAST BYTE
		bcc	NEXT4		;BRANCH IF NOT
;
		lda	CHKSUM		;GET CHECKSUM
		jsr	SNDBYT		;SEND IT
		txa				;CLEAR ACC
		rts				;RETURN
;
;
;
;		LOAD BLOCK SUBROUTINE
;		THIS SUB WILL SEARCH FOR A BLOCK ON
;		TAPE WITH AN IDENTIFIER THAT MATCHES
;		"IDENT".  WHEN FOUND, IT WILL TRANSFERS
;		THE BLOCK FROM TAPE TO MEMORY.
;		BEGINNING OF THE DESTINATION IS
;		SPECIFIED WITH "PNTER" AND END WITH
;		"ENDADR".  FOR THIS REASON THE SIZE
;		OF THE BLOCK MUST BE KNOWN.  ACC IS
;		RETURNED WITH "AA" FOR SUCCESSFUL LOAD
;		AND "EE" FOR ERROR.  X IS CLEARED,
;		Y IS SMACHES.  RELAYS ARE NOT AFFECTED.
;
LOAD:	ldx	#20			;SEARCH FOR LEADER
LOOP:	jsr	DETBIT		;GET A BIT
		bcc	LOAD		;START OVER IF "0" BIT
		dex				;20 BITS YET?
		bne	LOOP		;BRANCH IF NOT
		jsr	GETBYT		;GET IDENTIFIER FROM TAPE
		sta	DISPLY		;DISPLAY IT
		ldy	IDENT		;GET DESIRED ID
		beq	SKIP3		;SKIP COMPARISON IF ID=00
		cmp	IDENT		;CORRECT ID?
		bne	LOAD		;START OVER IF NOT
SKIP3:	stx	CHKSUM		;CLEAR CHECKSUM
;
NEXT5:	jsr	GETBYT		;GET A BYTE
		bcc	ERROR		;BRANCH IF STOP BIT=0
		sta	(PNTER,x)	;STORE BYTE BY POINTER
		jsr	CHKADD		;LAST BYTE?
		bcc	NEXT5		;IF NOT, GET NEXT BYTE
;
		jsr	GETBYT		;GET CHECKSUM
		ldy	#$AA		;A-OK MESSAGE
		cmp	CHKSUM		;IS CHECKSUM OK?
		beq	SKIP4		;SKIP ERROR MESSAGE IF SO
ERROR:	ldy	#$EE		;ERROR MESSAGE
SKIP4:	tya				;XFER MESSAGE TO ACC
		rts				;RETURN
;
;
END
		end